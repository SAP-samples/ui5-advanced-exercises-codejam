# Chapter 05 - Custom Controls and Third-Party Packages

By the end of this chapter we will have built a custom control that uses a third-party package ([Three.js](https://www.npmjs.com/package/three)) and allows users to visually explore the supermarket in a 3D model and find a selected product.

## Steps

- [1. Move 3D model into the application](#1-copy-3d-model-into-the-application)<br>
- [2. Install required dependencies](#2-install-required-dependencies)<br>
- [3. Add configuration to `ui5.yaml`](#3-add-configuration-to-ui5yaml)<br>
- [4. Create custom control skeleton](#4-create-custom-control-skeleton)<br>
- [5. Define metadata and private variables](#5-define-metadata-and-private-variables)<br>
- [6. Add lifecycle logic](#6-add-lifecycle-logic)<br>
- [7. Add control specific methods](#7-add-control-specific-methods)<br>
- [8. Add the renderer](#8-add-the-renderer)<br>
- [9. Use the custom control](#9-use-the-custom-control)<br>
- [10. Add CSS styling](#10-add-css-styling)<br>
- [11. Add CSS resource to `manifest.json`](#11-add-css-resource-to-manifestjson)<br>
- [12. Use custom control methods in controller](#12-use-custom-control-methods-in-controller)<br>
- [13. Test the custom control](#13-test-the-custom-control)<br>

### 1. Move 3D model into the application

Before the start with custom control development, let's provide the supermarket 3D model to the application.

➡️ Move the `application/uimodule/webapp/supermarket.glb` file (from the sample application included in this repo) into the `codejam.supermarket/uimodule/webapp` directory. You can do this via your file explorer or use this command:

```bash
mv ../application/uimodule/webapp/supermarket.glb uimodule/webapp/
```

### 2. Install required dependencies

➡️ Run the following commands in the `codejam.supermarket/` directory:

```bash
cd uimodule/
npm i ui5-tooling-modules @ui5/ts-interface-generator -D -rte
npm i three gsap
```

We installed the [`ui5-tooling-modules`](https://www.npmjs.com/package/ui5-tooling-modules) and [`@ui5/ts-interface-generator`](https://www.npmjs.com/package/@ui5/ts-interface-generator) as development dependencies (`-D`), as we will only require them during design time. The `ui5-tooling-modules` provide a middleware (and task) that let's us use NPM packages directly inside our UI5 app. We need this kind of middleware due to UI5's architectural independence from Node.js (UI5 apps can run on any server that serves static files). The `@ui5/ts-interface-generator` is required for custom control development and generates TypeScript interfaces which declare the methods generated by UI5 only at runtime.

We also installed the (non-development) dependencies [`three`](https://www.npmjs.com/package/three) and [`gsap`](https://www.npmjs.com/package/gsap), which are required for the custom control we will build. Three.js is a popular JavaScript library for creating 3D graphics, and `gsap` is a powerful animation library that we will use to animate the 3D model of the supermarket.

:information_source: With the command line option `-rte` the tooling extension `ui5-tooling-modules` adds its necessary configuration into the `ui5.yaml` automatically. Step 3 can be skipped in this case - just check that the configuration is present.

### 3. Add configuration to `ui5.yaml`

➡️ Add the following code to the `codejam.supermarket/uimodule/ui5.yaml` file inside the `customMiddleware` section:

```yaml
    - name: ui5-tooling-modules-middleware
      afterMiddleware: compression
```

➡️ Add the following code to the `codejam.supermarket/uimodule/ui5.yaml` file inside the `customTasks` section:

```yaml
    - name: ui5-tooling-modules-task
      afterTask: ui5-tooling-transpile-task
```

The above configuration adds the `ui5-tooling-modules` middleware (for the design time) and task (for the build). The middleware allows us to use NPM packages locally in our UI5 app, and the task ensures that the NPM packages are processed correctly during the build.

### 4. Create custom control skeleton

We can now get into the actual control development. Our custom control will essentially be only one file. Let's create the skeleton first and later fill in the details step-by-step.

➡️ Create a new file `codejam.supermarket/uimodule/webapp/ext/control/Supermarket.ts` with the following content:

```typescript
import Control from "sap/ui/core/Control"
import RenderManager from "sap/ui/core/RenderManager"
import { MetadataOptions } from "sap/ui/core/Element"
import {
	Scene,
	PerspectiveCamera,
	WebGLRenderer,
	AmbientLight
} from "three"
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'
import gsap from "gsap"
import BusyIndicator from "sap/m/BusyIndicator"
import Button from "sap/m/Button"

/**
 * @namespace uimodule.ext.control
 */
export default class Supermarket extends Control {

	static readonly metadata: MetadataOptions = {
		properties: {},
		aggregations: {}
	}

    // placeholder for some private variables

	init(): void {}

	onAfterRendering(): void {}

	private animate(): void {}

	public setCameraPosition(): void {}

	public expand(): void {}

	static renderer = {
		apiVersion: 4,
		render: (rm: RenderManager, control: Supermarket) => {}
	}
}
```

Our custom control extends UI5's base class control (`sap/ui/core/Control`), which means it inherits all of its methods (incl. the lifecycle methods `init()` and `onAfterRendering()`) and core capabilities. We also add more `metadata` and other methods specific to our custom control. Most importantly, we define a `renderer` for our custom control, which will include the rendered HTML elements that make up the control.

Feel free to check out the UI5 documentation for [guidelines on how to develop controls](https://ui5.sap.com/#/topic/8dcab0011d274051808f959800cabf9f).

### 5. Define metadata and private variables

➡️ Replace the empty `metadata` and the `// placeholder for some private variables` in the `codejam.supermarket/uimodule/webapp/ext/control/Supermarket.ts` file with the following code:

```typescript
	static readonly metadata: MetadataOptions = {
		properties: {
			x: { type: "float", defaultValue: 20.69 },
			y: { type: "float", defaultValue: 10.12 },
			z: { type: "float", defaultValue: -28.03 },
			growFactor: { type: "float", defaultValue: 2 }
		},
		aggregations: {
			_busyIndicator: {
				type: "sap.m.BusyIndicator",
				multiple: false
			},
			_expand: {
				type: "sap.m.Button",
				multiple: false
			}
		}
	}

	private scene: Scene
	private camera: PerspectiveCamera
	private threeRenderer: WebGLRenderer
	private controls: OrbitControls
	private animationSpeed = 3000
	private height: Number
	private width: Number
```

The above metadata (incl. properties and aggregations) and variables lay the foundation for our custom control.

**Properties**: In simple terms, properties are the configuration options that can be set when consuming the control (in an XML view, for example). The UI5 runtime will also generate getter and setter methods for these properties (e.g.`getX()` and `setX()`). The `x`, `y`, and `z` coordinates define the camera position in the 3D model, and the `growFactor` property defines how much the control should grow when expanded. The hardcoded default values for the coordinates describe the cameras initial position.

**Aggregations**: Aggregations are children-like UI5 controls that our custom control will contains. In our case, we only define two aggregations that we use "internally" (not to be modified by the control consumer): A `BusyIndicator` to show a loading indicator while the 3D model is being loaded, and a `Button` to expand the control to a larger size. The `multiple: false` means that we only allow one instance of these aggregations (unlike in a list binding).

**Private variables**: We define some private variables that we will later need for the animations and calculations inside the control.

### 6. Add lifecycle logic

➡️ Replace the empty `init()` and `onAfterRendering()` methods in the `codejam.supermarket/uimodule/webapp/ext/control/Supermarket.ts` file with the following code:

```typescript
	init(): void {
		this.setAggregation("_busyIndicator", new BusyIndicator({
			visible: true
		}))
		this.setAggregation("_expand", new Button({
			icon: "sap-icon://full-screen",
			press: this.expand.bind(this, {})
		}))
	}

	onAfterRendering(): void {
		const canvas = this.getDomRef() as HTMLCanvasElement;
		const { width, height } = canvas.getBoundingClientRect()

		this.height = height
		this.width = width

		this.threeRenderer = new WebGLRenderer({
			canvas: canvas,
		})
		this.threeRenderer.setSize(width, height)

		this.scene = new Scene()
		this.camera = new PerspectiveCamera(75, width / height, 0.1, 1000)

		const ambientLight = new AmbientLight(0xffffff)
		this.scene.add(ambientLight)

		const loader = new GLTFLoader()
		loader.load("supermarket.glb", gltf => {
			this.scene.add(gltf.scene)
			this.setCameraPosition([{ x: 18.88, y: 2.44, z: -5.2 }], {})
			const busyIndicator = this.getAggregation("_busyIndicator") as BusyIndicator
			busyIndicator.setVisible(false)
		})

		this.controls = new OrbitControls(this.camera, this.threeRenderer.domElement)

		this.animate()

		this.camera.position.set(this.getX(), this.getY(), this.getZ())
	}
```

In the `init()` methods, which gets executed when the control is being initialized, we set the `_busyIndicator` and `_expand` aggregations that we defined in the metadata.

In the `onAfterRendering()` method, which gets executed after the control has been rendered, we create the 3D model. We do this by getting the  `canvas` element from the rendered control (see step 8) and passing it to a newly instantiated `WebGLRenderer`. We also instantiate the following classes which are required to make a Three.js scene work:
- `Scene` (required)
- `PerspectiveCamera` (so that there is a camera to look at the 3D model)
- `AmbientLight` (so it's not completely dark)
- `GLTFLoader` (to load the 3D model file from step 1)
- `OrbitControls` (so we can use the mouse to navigate in the 3D model) 

### 7. Add control specific methods

➡️ Replace the empty `animate()`, `setCameraPosition()`, and `expand()` methods in the `codejam.supermarket/uimodule/webapp/ext/control/Supermarket.ts` file with the following code:

```typescript
	private animate(): void {
		this.threeRenderer.render(this.scene, this.camera)
		this.controls.update()
		requestAnimationFrame(this.animate.bind(this))
	}

	public setCameraPosition(coordinates: Array<Object>, { backToStart = false }: { backToStart?: Boolean }): void {
		if (backToStart) {
			this.camera.position.set(18.88, 2.44, -5.2)
		}
		gsap.to(this.camera.position, { ...coordinates[0], duration: this.animationSpeed / 1000 })
		for (let i = 1; i < coordinates.length; i++) {
			window.setTimeout(() => {
				gsap.to(this.camera.position, { ...coordinates[i], duration: this.animationSpeed / 1000 })
			}, this.animationSpeed)
		}
	}

	public expand({ stayExpanded = false }: { stayExpanded?: Boolean }): void {
		const expand = this.getAggregation("_expand") as Button
		const growFactor = this.getGrowFactor()
		const icon = expand.getIcon()
		const factor = icon === "sap-icon://full-screen" || stayExpanded ? growFactor : 1
		// @ts-ignore
		this.getParent().getDomRef().style.height = `${this.height * factor}px`
		// @ts-ignore
		this.getParent().getDomRef().style.width = `${this.width * factor}px`
		// @ts-ignore
		this.threeRenderer.setSize(this.width * factor, this.height * factor)
		expand.setIcon(`sap-icon://${factor === growFactor ? "exit-" : ""}full-screen`)
	}
```

We defined three methods that are specific to our custom control:
1. The `animate()` method is private and only used internally to render, update, and animate the 3D model.
2. The `setCameraPosition()` method is public and allows the control consumer to set the camera position in the 3D model (x, y, z coordinates).
3. The `expand()` method is also public and allows the control consumer to expand the control to a larger size. It uses the `growFactor` property defined in the metadata to calculate the new size of the control.

### 8. Add the renderer

➡️ Replace the `renderer` in the `codejam.supermarket/uimodule/webapp/ext/control/Supermarket.ts` file with the following code:

```typescript
	static renderer = {
		apiVersion: 4,
		render: (rm: RenderManager, control: Supermarket) => {
			rm.openStart("canvas", control)
			rm.style("height", "100%")
			rm.style("width", "100%")
			rm.openEnd()
			rm.close("canvas")
			rm.openStart("div")
			rm.style("position", "absolute")
			rm.style("top", "0")
			rm.style("width", "100%")
			rm.style("height", "100%")
			rm.style("display", "flex")
			rm.style("align-items", "center")
			rm.style("justify-content", "center")
			rm.style("pointer-events", "none")
			rm.openEnd()
			rm.renderControl(control.getAggregation("_busyIndicator") as Control)
			rm.close("div")
			rm.openStart("div")
			rm.style("position", "absolute")
			rm.style("top", "0.5rem")
			rm.style("left", "0.5rem")
			rm.openEnd()
			rm.renderControl(control.getAggregation("_expand") as Control)
			rm.close("div")
		}
	}
```

The renderer is responsible for creating the HTML elements that make up our custom control. We defined the HTML elements and their styles using TypeScript. We also use the `rm.renderControl()` method to render the aggregations (like children UI5 controls inside our custom control) that we defined earlier.

### 9. Use the custom control

Now that we have our custom control ready, we can use it in our UI5 app.

➡️ Add the following code to the `codejam.supermarket/uimodule/webapp/ext/main/Main.view.xml` file (it doesn't really matter where, as we will set a fixed position in the next step):

```xml
			<FlexBox class="fixed">
				<cc:Supermarket id="supermarket" />
			</FlexBox>
```

➡️ Also make sure to add the following namespace to the opening `<mvc:View>` tag at the top of the file, to make the view aware of the `control/` directory where we created our custom control:


```xml
xmlns:cc="uimodule.ext.control"
```

### 10. Add CSS styling

➡️ Create a new file `codejam.supermarket/uimodule/webapp/css/style,css` with the following content:

```css
.fixed {
	position: fixed;
	display: flex;
	bottom: 1rem;
	right: 1rem;
	height: 200px;
	width: 400px;

	justify-content: center;
	border-radius: 1rem;
	overflow: hidden;
	z-index: 9999;
}
```

This `.fixed` CSS class is used on the `FlexBox` that wraps around our custom control when used in the XML view. Arguably, we could have included the `FlexBox` along with the styling as part of our custom control itself, but it makes sense to keep the custom control as independent as possible, and let the developer who uses it decide how to position it.

### 11. Add CSS resource to `manifest.json`

➡️ Add the following code to the `sap.ui5.resources.css` section in the `codejam.supermarket/uimodule/webapp/manifest.json` file:

```json
				{
					"uri": "css/style.css"
				}
```

### 12. Use custom control methods in controller

➡️ Add the following method to the `codejam.supermarket/uimodule/webapp/ext/main/Main.controller.ts` file:

```typescript
	public onFlyToProduct(event: Button$PressEvent): void {
		const source = event.getSource()
		const context = source.getBindingContext()
		const position = context?.getProperty("position")
		const supermarket = this.getView()?.byId("supermarket") as Supermarket
		supermarket.expand({ stayExpanded: true })
		supermarket.setCameraPosition(JSON.parse(position), { backToStart: true })
	}
```

➡️ Also make sure to add the following imports to the top of the same file:

```typescript
import { Button$PressEvent } from "sap/m/Button";
import Supermarket from "../control/Supermarket";
```

With this method (which is invoked on the `press` event of the product tiles - check the xml view), we can fly to a specific product in the 3D model. For that, we first get the data for the position of the product from its context, and then use this data for the `setCameraPosition` method (after using `expand`) of our supermarket custom control.

If you feel like it, you can test the code completion (powered by TypeScript) by typing `supermarket.` at the end of the method. You should see all available methods (obviously only the public ones) plus their documentation inside your IDE. Pretty nice, isn't it?

### 13. Test the custom control

➡️ Refresh your browser window at `http://localhost:4004/` and test the application. In case you closed your server, restart it with the following command from the project root:

```bash
# make sure you are in the codejam.supermarket/ directory (project root)
npm run dev:server
```

The application now includes the custom control that uses third-party packages. Click on a product tile to test it. Also feel free to expand the 3D model and navigate around using the mouse.

![application](./application.gif)

Continue to [Chapter 06 - Testing: Current Project Setup](/chapters/06-testing-current-project-setup/)
